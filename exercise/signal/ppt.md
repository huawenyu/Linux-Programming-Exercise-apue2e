# Signals

On Unix systems, there are several ways to send signals:
- User processes/shell with a kill command,
- Signals are also generated by the program itself
  + through your own program (e.g., call a kill/abort/signal/raise in C).
  + hardware exceptions such as segmentation faults and illegal instructions,
  + execute an illegal instruction like dividing by zero,
  + access a memory zone that has not been allocated yet,
- the Kernel:
  + with a keyboard sequence (like control-C),
    - SIGINT   Ctrl+C
    - SIGQUIT  Ctrl+\
    - SIGSTOP  Ctrl+z
  + timers and child process termination.
    - SIGCHLD  Child stopped or terminated

# Signal Terminology
- Generated - The signal is being created in the kernel by the kill system call.
- Pending - Not delivered yet but soon to be delivered
- Blocked - Not delivered because no signal disposition lets the signal be delivered
- Delivered - Delivered to the process, the action described is being taken
- Caught - When the process stops a signal from destroying it and does something else with it instead

# Signals Handle

A signal may have one of three different dispositions or "actions taken" when it is delivered to a process:

- SIG_DFL: take the default or "normal" action.
- SIG_IGN: ignore the signal (take no action).
- user-defined: the signal is "caught" by a user-defined signal handler.

- One more handle option is Block signal from kernel.

But we can't ignore/catch/block two signals: SIGKILL and SIGSTOP.


# Demo

- Demo of signals user-defined
- Demo of signal blocked
- Demo of signals ignore

## Demo of signals user-defined


```c
/**
User-defined signal catch.

>>> echo ---------------------
>>> echo Check signal-repeat: for i in {1..30}; do kill -35 <pid>; done
>>> {fileout}

*/

  #include <errno.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  #include <stdarg.h>
  #include <signal.h>

  #define my_printf(...) printf(__VA_ARGS__)

  void perror2(const char *fmt, ...)
  {
      int errnum = errno;

      fprintf(stderr, "(%d: %s) ", errnum, strerror(errnum));
      va_list args;
      va_start(args, fmt);

      vfprintf(stderr, fmt, args);
      va_end(args);
      fprintf(stderr, "\n");
  }

  int sigCnt;

  void sigint_handler(int sig)
  {
     // Do thing
     sigCnt ++;
  }

  int main()
  {
      int ret;

      /* Install the SIGINT handler */
      if (signal(SIGINT, sigint_handler) == SIG_ERR)
         perror2("signal error");

      if (signal(35, sigint_handler) == SIG_ERR)
         perror2("signal error");

  again:
      printf("\n  Pause to waiting signal pid=%d \n", getpid());
      ret = pause(); /* Wait for the receipt of a signal, then returns -1, and errno is set to EINTR. */
      perror2("signal delivered ret=%d sigCnt=%d", ret, sigCnt);
      if (sigCnt < 30)
          goto again;

      return 0;
  }
```

## Demo of signal blocked

What's different bwteen signal-block/signal-ignore/signal-donothing-handler?

```c
/*

https://csresources.github.io/SystemProgrammingWiki/SystemProgramming/Signals,-Part-2:-Pending-Signals-and-Signal-Masks/
https://www.oracle.com/technical-resources/articles/it-infrastructure/dev-signal-handlers-studio.html
https://www.gnu.org/software/libc/manual/html_node/Why-Block.html

>>> echo ========signal-block============
>>> echo --------Check SigQ: normal-signal -----------
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --  kill -10 <pid>
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --  kill -10 <pid>
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --------Check SigQ: realtime-signal -----------
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --  kill -55 <pid>
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --  kill -55 <pid>
>>> echo --  cat /proc/<pid>/status| grep Sig

>>> echo signals.sh 0 <pid>
>>> echo --------------------
>>> {fileout}

*/

  #include <errno.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  #include <stdarg.h>
  #include <signal.h>

  #define my_printf(...) printf(__VA_ARGS__)

  void perror2(const char *fmt, ...)
  {
      int errnum = errno;

      fprintf(stderr, "(%d: %s) ", errnum, strerror(errnum));
      va_list args;
      va_start(args, fmt);

      vfprintf(stderr, fmt, args);
      va_end(args);
      fprintf(stderr, "\n");
  }

  int sigIdx;
  int sigs[128];

  void sigint_handler(int sig)
  {
      sigs[sigIdx++] = sig;
  }

  int main()
  {
      int ret;
      int count = 0;
      sigset_t set, oldset;

      sigfillset(&set); // all signals
      sigprocmask(SIG_SETMASK, &set, NULL); // Block all the signals!
      // (Actually SIGKILL or SIGSTOP cannot be blocked...)

      // Install handler
      struct sigaction act;

      memset(&act, 0, sizeof(act));
      act.sa_handler = sigint_handler;
      //act.sa_sigaction = sigint_handler;
      act.sa_flags = SA_RESTART | SA_SIGINFO;
      sigemptyset(&act.sa_mask);
      for (int i=1; i < 65; i++) {
          //printf("i = %d\n", i);

          // 9-SIGKILL and 19-SIGSTOP cannot be caught or ignored
          // 32 and 33 do not exist
          if (i == SIGKILL ||
              i == SIGSTOP ||
              i == 32 ||
              i == 33)
              continue;

          if (0 != sigaction(i, &act, NULL))
              perror2("signal error: sig=%d", i);
      }

  again:
      printf("Press Enter to Un-block all pid=%d at (%d < 3) times.\n", getpid(), count);
      // for (int i=0; i < 30; i++) { sleep(1); }

      /**
      // Block and wait until a signal arrives
      while (1) {
          sigsuspend(&sig_a.sa_mask);
          printf("loop\n");
      }
      */

      getchar();

      count ++;
      if (count < 3) {
          sigemptyset(&set); // no signals
          sigprocmask(SIG_SETMASK, &set, NULL); // Un-block all the signals: set the mask to be empty
          goto again;
      }

      // Dump all triggered signals
      printf("\nSignals:");
      for (int i=0; i < 128; i++) {
          if (sigs[i])
              printf("%d ", sigs[i]);
      }
      printf("End\n");
      return 0;
  }
```

## Demo of signals ignore

```c
/*

Other comments & note:

>>> echo ========signal-ignore============
>>> echo --  cat /proc/<pid>/status| grep Sig
>>> echo --  echo fffffffe7ffbfeff | xxd -r -p | xxd -c64 -b | cut -d' ' -f6-9
>>> echo signals.sh 0 <pid>
>>> echo --------------------
>>> {fileout}

*/

  #include <errno.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <unistd.h>

  #include <stdarg.h>
  #include <signal.h>

  void perror2(const char *fmt, ...)
  {
      int errnum = errno;

      fprintf(stderr, "(%d: %s) ", errnum, strerror(errnum));
      va_list args;
      va_start(args, fmt);

      vfprintf(stderr, fmt, args);
      va_end(args);
      fprintf(stderr, "\n");
  }

  int main()
  {
      struct sigaction act;

      act.sa_handler = SIG_IGN;
      for (int i = 1 ; i < 65 ; i++) {
          //printf("i = %d\n", i);

          // 9-SIGKILL and 19-SIGSTOP cannot be caught or ignored
          // 32 and 33 do not exist
          if (i == SIGKILL ||
              i == SIGSTOP ||
              i == 32 ||
              i == 33)
              continue;

          //if (0 != signal(i, SIG_IGN))
          if (0 != sigaction(i, &act, NULL))
              perror2("signal error: sig=%d", i);
      }

      printf("Press Enter to Continue pid=%d ", getpid());
      getchar();
      return 0;
  }
```
